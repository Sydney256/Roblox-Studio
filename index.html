<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Web Studio</title>
<style>
  body, html { margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
  #ui { position: absolute; top: 0; left: 0; width: 300px; height: 100%; background: #1b1e25; color: white; padding: 10px; box-sizing: border-box; overflow-y: auto; }
  #inspector { position: absolute; top: 0; right: 0; width: 300px; height: 100%; background: #1b1e25; color: white; padding: 10px; box-sizing: border-box; overflow-y: auto; }
  button { width: 100%; margin: 5px 0; padding: 8px; background: #2b2f37; border: none; color: white; cursor: pointer; }
  button:hover { background: #3b3f47; }
  input { width: 100%; margin: 5px 0; padding: 4px; background: #2b2f37; border: none; color: white; }
  label { font-size: 12px; }
  #sceneGraph div { cursor: pointer; padding: 2px; }
  #sceneGraph div.selected { background: #3b3f47; }
</style>
</head>
<body>
<div id="ui">
  <h2>Objects</h2>
  <button onclick="addObject('box')">Add Box</button>
  <button onclick="addObject('sphere')">Add Sphere</button>
  <button onclick="addObject('plane')">Add Plane</button>
  <h2>Scene</h2>
  <div id="sceneGraph"></div>
  <button onclick="exportScene()">Export JSON</button>
  <input type="file" id="importFile">
</div>
<div id="inspector">
  <h2>Inspector</h2>
  <div id="inspectorContent">Select an object</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.163.0/examples/js/controls/OrbitControls.js"></script>
<script>
  // Scene setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f1724);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(5,5,5);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Orbit controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff,0.5); scene.add(ambient);
  const dirLight = new THREE.DirectionalLight(0xffffff,1);
  dirLight.position.set(5,10,5); dirLight.castShadow = true; scene.add(dirLight);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(100,100);
  const groundMat = new THREE.MeshStandardMaterial({color:0x202225});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Grid helper
  const grid = new THREE.GridHelper(100,100,0x2b2f33,0x2f3337);
  scene.add(grid);

  // Objects array
  let objects = [];
  let selected = null;

  // Utilities
  function uid() { return Math.random().toString(36).slice(2,9); }

  // Scene Graph UI
  const sceneGraphDiv = document.getElementById('sceneGraph');
  const inspectorContent = document.getElementById('inspectorContent');

  function updateSceneGraph() {
    sceneGraphDiv.innerHTML = '';
    objects.forEach(obj => {
      const div = document.createElement('div');
      div.textContent = obj.userData.name;
      div.className = (selected === obj) ? 'selected':'';
      div.onclick = () => { selectObject(obj); };
      sceneGraphDiv.appendChild(div);
    });
  }

  function selectObject(obj) {
    selected = obj;
    updateSceneGraph();
    updateInspector();
  }

  function addObject(type) {
    let mesh;
    if(type==='box') {
      const geo = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshStandardMaterial({color: 0x3478f6});
      mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = 0.5;
    } else if(type==='sphere') {
      const geo = new THREE.SphereGeometry(0.5,32,32);
      const mat = new THREE.MeshStandardMaterial({color: 0x34d399});
      mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = 0.5;
    } else if(type==='plane') {
      const geo = new THREE.BoxGeometry(2,0.1,2);
      const mat = new THREE.MeshStandardMaterial({color: 0xf97316});
      mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = 0.05;
    }
    mesh.userData = {id: uid(), name: type[0].toUpperCase()+type.slice(1), type};
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    objects.push(mesh);
    selectObject(mesh);
  }

  function updateInspector() {
    if(!selected){ inspectorContent.innerHTML = 'Select an object'; return; }
    inspectorContent.innerHTML = '';
    const nameLabel = document.createElement('label'); nameLabel.textContent='Name'; inspectorContent.appendChild(nameLabel);
    const nameInput = document.createElement('input'); nameInput.value = selected.userData.name;
    nameInput.oninput = e=>{ selected.userData.name = e.target.value; updateSceneGraph(); };
    inspectorContent.appendChild(nameInput);

    const props = ['position','rotation','scale'];
    props.forEach(prop=>{
      const label = document.createElement('label'); label.textContent = prop; inspectorContent.appendChild(label);
      selected[prop].forEach((val,i)=>{
        const input = document.createElement('input'); input.value = val.toFixed(2);
        input.oninput = e=>{
          selected[prop][i] = parseFloat(e.target.value)||0;
        };
        inspectorContent.appendChild(input);
      });
    });

    // Color picker
    const colorLabel = document.createElement('label'); colorLabel.textContent='Color'; inspectorContent.appendChild(colorLabel);
    const colorInput = document.createElement('input'); colorInput.type='color';
    colorInput.value = '#'+selected.material.color.getHexString();
    colorInput.oninput = e=>{ selected.material.color.set(e.target.value); };
    inspectorContent.appendChild(colorInput);

    // Delete button
    const delBtn = document.createElement('button'); delBtn.textContent='Delete';
    delBtn.onclick = ()=>{
      scene.remove(selected);
      objects = objects.filter(o=>o!==selected);
      selected = null;
      updateSceneGraph(); updateInspector();
    };
    inspectorContent.appendChild(delBtn);

    // Duplicate button
    const dupBtn = document.createElement('button'); dupBtn.textContent='Duplicate';
    dupBtn.onclick = ()=>{
      const clone = selected.clone();
      clone.position.x +=1; clone.position.z +=1;
      clone.userData.id = uid(); clone.userData.name += ' Copy';
      scene.add(clone); objects.push(clone);
      selectObject(clone);
    };
    inspectorContent.appendChild(dupBtn);
  }

  // Drag to move objects
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let dragging = false;

  renderer.domElement.addEventListener('pointerdown', e=>{
    mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(objects);
    if(intersects.length){ dragging = true; selectObject(intersects[0].object); }
  });
  renderer.domElement.addEventListener('pointerup', e=>{ dragging=false; });
  renderer.domElement.addEventListener('pointermove', e=>{
    if(!dragging||!selected) return;
    mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
    raycaster.setFromCamera(mouse,camera);
    const plane = new THREE.Plane(new THREE.Vector3(0,1,0),0);
    const point = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, point);
    selected.position.x = point.x;
    selected.position.z = point.z;
    updateInspector();
  });

  // Export/Import
  function exportScene() {
    const data = objects.map(o=>({
      type:o.userData.type,
      position: o.position.toArray(),
      rotation: o.rotation.toArray(),
      scale: o.scale.toArray(),
      color: '#'+o.material.color.getHexString(),
      name: o.userData.name
    }));
    const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='scene.json'; a.click();
  }

  document.getElementById('importFile').addEventListener('change', e=>{
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = ev=>{
      try{
        const data = JSON.parse(ev.target.result);
        objects.forEach(o=>scene.remove(o));
        objects=[];
        data.forEach(d=>{
          let mesh;
          if(d.type==='box'){ mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:d.color})); }
          else if(d.type==='sphere'){ mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshStandardMaterial({color:d.color})); }
          else if(d.type==='plane'){ mesh = new THREE.Mesh(new THREE.BoxGeometry(2,0.1,2), new THREE.MeshStandardMaterial({color:d.color})); }
          mesh.position.fromArray(d.position);
          mesh.rotation.fromArray(d.rotation);
          mesh.scale.fromArray(d.scale);
          mesh.castShadow=true; mesh.receiveShadow=true;
          mesh.userData={id: uid(), name:d.name, type:d.type};
          scene.add(mesh); objects.push(mesh);
        });
        selected=null; updateSceneGraph(); updateInspector();
      }catch(err){ alert('Failed to import: '+err.message);}
    };
    reader.readAsText(file);
  });

  // Handle resize
  window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // Render loop
  function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
  animate();
</script>
</body>
</html>
