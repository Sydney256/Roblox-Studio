<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Web Studio Pro</title>
<style>
  body, html { margin:0; padding:0; overflow:hidden; font-family:sans-serif; }
  #ui { position:absolute; top:0; left:0; width:300px; height:100%; background:#1b1e25; color:white; padding:10px; box-sizing:border-box; overflow-y:auto; }
  #inspector { position:absolute; top:0; right:0; width:300px; height:100%; background:#1b1e25; color:white; padding:10px; box-sizing:border-box; overflow-y:auto; }
  button { width:100%; margin:5px 0; padding:8px; background:#2b2f37; border:none; color:white; cursor:pointer; }
  button:hover { background:#3b3f47; }
  input { width:100%; margin:5px 0; padding:4px; background:#2b2f37; border:none; color:white; }
  label { font-size:12px; }
  #sceneGraph div { cursor:pointer; padding:2px; }
  #sceneGraph div.selected { background:#3b3f47; }
</style>
</head>
<body>
<div id="ui">
  <h2>Objects</h2>
  <button onclick="addObject('box')">Add Box</button>
  <button onclick="addObject('sphere')">Add Sphere</button>
  <button onclick="addObject('plane')">Add Plane</button>
  <label><input type="checkbox" id="snapToggle" checked> Snap to Grid</label>
  <h2>Scene</h2>
  <div id="sceneGraph"></div>
  <button onclick="exportScene()">Export JSON</button>
  <input type="file" id="importFile">
</div>
<div id="inspector">
  <h2>Inspector</h2>
  <div id="inspectorContent">Select object(s)</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.163.0/examples/js/controls/OrbitControls.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1724);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(5,5,5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const ambient = new THREE.AmbientLight(0xffffff,0.5);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(5,10,5);
dirLight.castShadow = true;
scene.add(dirLight);

const groundGeo = new THREE.PlaneGeometry(100,100);
const groundMat = new THREE.MeshStandardMaterial({color:0x202225});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

const grid = new THREE.GridHelper(100,100,0x2b2f33,0x2f3337);
scene.add(grid);

let objects = [];
let selectedObjects = [];
let hovered = null;
let snap = 1;

const sceneGraphDiv = document.getElementById('sceneGraph');
const inspectorContent = document.getElementById('inspectorContent');

function uid(){ return Math.random().toString(36).slice(2,9); }

function updateSceneGraph(){
  sceneGraphDiv.innerHTML='';
  objects.forEach(obj=>{
    const div = document.createElement('div');
    div.textContent = obj.userData.name;
    div.className = selectedObjects.includes(obj) ? 'selected':'';
    div.onclick = e=>{
      if(e.shiftKey){
        if(selectedObjects.includes(obj)) selectedObjects = selectedObjects.filter(o=>o!==obj);
        else selectedObjects.push(obj);
      } else { selectedObjects=[obj]; }
      updateSceneGraph(); updateInspector();
    };
    sceneGraphDiv.appendChild(div);
  });
}

function addObject(type){
  let mesh;
  if(type==='box'){ mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x3478f6})); mesh.position.y=0.5;}
  if(type==='sphere'){ mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshStandardMaterial({color:0x34d399})); mesh.position.y=0.5;}
  if(type==='plane'){ mesh = new THREE.Mesh(new THREE.BoxGeometry(2,0.1,2), new THREE.MeshStandardMaterial({color:0xf97316})); mesh.position.y=0.05;}
  mesh.castShadow=true; mesh.receiveShadow=true;
  mesh.userData={id:uid(), name:type[0].toUpperCase()+type.slice(1), type};
  scene.add(mesh); objects.push(mesh);
  selectedObjects=[mesh]; updateSceneGraph(); updateInspector();
}

function updateInspector(){
  inspectorContent.innerHTML='';
  if(selectedObjects.length===0){ inspectorContent.textContent='Select object(s)'; return;}
  selectedObjects.forEach(obj=>{
    const title = document.createElement('div'); title.textContent=obj.userData.name; title.style.fontWeight='bold'; inspectorContent.appendChild(title);

    // Name
    const nameLabel = document.createElement('label'); nameLabel.textContent='Name'; inspectorContent.appendChild(nameLabel);
    const nameInput = document.createElement('input'); nameInput.value=obj.userData.name;
    nameInput.oninput=e=>{ obj.userData.name=e.target.value; updateSceneGraph();}
    inspectorContent.appendChild(nameInput);

    // Position
    ['x','y','z'].forEach((axis,i)=>{
      const label = document.createElement('label'); label.textContent='Pos '+axis; inspectorContent.appendChild(label);
      const input = document.createElement('input'); input.value=obj.position[axis]; input.oninput=e=>{
        obj.position[axis]=parseFloat(e.target.value)||0;
      }; inspectorContent.appendChild(input);
    });

    // Rotation
    ['x','y','z'].forEach((axis,i)=>{
      const label = document.createElement('label'); label.textContent='Rot '+axis; inspectorContent.appendChild(label);
      const input = document.createElement('input'); input.value=obj.rotation[axis]; input.oninput=e=>{
        obj.rotation[axis]=parseFloat(e.target.value)||0;
      }; inspectorContent.appendChild(input);
    });

    // Scale
    ['x','y','z'].forEach((axis,i)=>{
      const label = document.createElement('label'); label.textContent='Scale '+axis; inspectorContent.appendChild(label);
      const input = document.createElement('input'); input.value=obj.scale[axis]; input.oninput=e=>{
        obj.scale[axis]=parseFloat(e.target.value)||0.1;
      }; inspectorContent.appendChild(input);
    });

    // Color
    const colorLabel=document.createElement('label'); colorLabel.textContent='Color'; inspectorContent.appendChild(colorLabel);
    const colorInput=document.createElement('input'); colorInput.type='color'; colorInput.value='#'+obj.material.color.getHexString();
    colorInput.oninput=e=>{ obj.material.color.set(e.target.value);}
    inspectorContent.appendChild(colorInput);

    // Delete
    const delBtn=document.createElement('button'); delBtn.textContent='Delete'; delBtn.onclick=()=>{
      selectedObjects.forEach(o=>{scene.remove(o); objects=objects.filter(x=>x!==o);});
      selectedObjects=[]; updateSceneGraph(); updateInspector();
    }; inspectorContent.appendChild(delBtn);

    // Duplicate
    const dupBtn=document.createElement('button'); dupBtn.textContent='Duplicate'; dupBtn.onclick=()=>{
      selectedObjects.forEach(o=>{
        const clone=o.clone();
        clone.position.x+=1; clone.position.z+=1;
        clone.userData={...o.userData, id:uid(), name:o.userData.name+' Copy'};
        scene.add(clone); objects.push(clone);
      }); updateSceneGraph();
    }; inspectorContent.appendChild(dupBtn);
  });
}

const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
let dragging=false;

renderer.domElement.addEventListener('pointerdown', e=>{
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const intersects=raycaster.intersectObjects(objects);
  if(intersects.length){ dragging=true; const obj=intersects[0].object;
    if(!selectedObjects.includes(obj)){
      if(e.shiftKey) selectedObjects.push(obj);
      else selectedObjects=[obj];
    } updateSceneGraph(); updateInspector();}
});

renderer.domElement.addEventListener('pointerup', e=>{ dragging=false; });
renderer.domElement.addEventListener('pointermove', e=>{
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
  if(!dragging||selectedObjects.length===0) return;
  raycaster.setFromCamera(mouse,camera);
  const plane=new THREE.Plane(new THREE.Vector3(0,1,0),0);
  const point=new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, point);
  const snapEnabled=document.getElementById('snapToggle').checked;
  selectedObjects.forEach(obj=>{
    obj.position.x=snapEnabled?Math.round(point.x/snap)*snap:point.x;
    obj.position.z=snapEnabled?Math.round(point.z/snap)*snap:point.z;
  });
  updateInspector();
});

function exportScene(){
  const data=objects.map(o=>({
    type:o.userData.type,
    position:o.position.toArray(),
    rotation:o.rotation.toArray(),
    scale:o.scale.toArray(),
    color:'#'+o.material.color.getHexString(),
    name:o.userData.name
  }));
  const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='scene.json'; a.click();
}

document.getElementById('importFile').addEventListener('change', e=>{
  const file=e.target.files[0]; const reader=new FileReader();
  reader.onload=ev=>{
    try{
      const data=JSON.parse(ev.target.result);
      objects.forEach(o=>scene.remove(o)); objects=[];
      data.forEach(d=>{
        let mesh;
        if(d.type==='box') mesh=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:d.color}));
        if(d.type==='sphere') mesh=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32),new THREE.MeshStandardMaterial({color:d.color}));
        if(d.type==='plane') mesh=new THREE.Mesh(new THREE.BoxGeometry(2,0.1,2),new THREE.MeshStandardMaterial({color:d.color}));
        mesh.position.fromArray(d.position); mesh.rotation.fromArray(d.rotation); mesh.scale.fromArray(d.scale);
        mesh.castShadow=true; mesh.receiveShadow=true; mesh.userData={id:uid(), name:d.name, type:d.type};
        scene.add(mesh); objects.push(mesh);
      });
      selectedObjects=[]; updateSceneGraph(); updateInspector();
    } catch(err){alert('Failed to import: '+err.message);}
  };
  reader.readAsText(file);
});

window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
animate();
</script>
</body>
</html>
